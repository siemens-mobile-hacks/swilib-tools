--- C81.vkp	2024-06-17 14:08:49.318648028 +0300
+++ C81_merged222.vkp	2024-06-20 15:03:31.565756680 +0300
@@ -1,5 +1,7 @@
-+0074000
+; C81v51
++00074000
 #pragma enable old_equal_ff
+
 0000: 0xA0002070   ;   0: void loopback0()
 0004: 0xA0002070   ;   1: void loopback1()
 0008: 0xA0002070   ;   2: void loopback2()
@@ -14,7 +16,7 @@
 002C: 0xA02525EC   ;   B: int fread(int FileHandler, void *cBuffer, int iByteCount, unsigned int *ErrorNumber)
 0030: 0xA025271C   ;   C: unsigned int fwrite(int FileHandler, void const *cBuffer, int iByteCount, unsigned int *ErrorNumber)
 0034: 0xA0252480   ;   D: void fclose(int FileHandler, unsigned int *ErrorNumber)
-038:  0xA02524B0   ;   E: fflush
+0038: 0xA02524B0   ;   E: fflush
 003C: 0xA02524E0   ;   F: unsigned int lseek(int FileHandler, unsigned int offset, unsigned int origin, unsigned int *ErrorNumber, unsigned int *ErrorNumber2)
 
 0040: 0xA0252124   ;  10: int mkdir(const char *cFileName, unsigned int *ErrorNumber)
@@ -34,7 +36,7 @@
 0078: 0xA096BA5D   ;  1E: IMGHDR *GetPITaddr(int num)
 007C: 0xA03036D7   ;  1F: DrawMainScreen
 
-0080: 0xA050FCE5   ;  20: DrawScreenSaver
+0080: 0xA030474F   ;  20: void DrawScreenSaver()
 0084: 0xA096BB87   ;  21: int GetImgHeight(int picture)
 0088: 0xA096BB97   ;  22: int GetImgWidth(int picture)
 008C: 0xA029C939   ;  23: void DrawImg(unsigned int x, unsigned int y, unsigned int picture)
@@ -43,7 +45,7 @@
 0098: 0xA09FF981   ;  26: void DrawImgBW(unsigned int x, unsigned int y, unsigned int picture, char *pen, char *brush)
 009C: 0xA029C0C1   ;  27: AddIconToIconbar
 ;0A0:              ;  28: uint32_t GetEELiteMaxID()
-0A4:  0xA01E4F6C   ;  29: getEEFullMaxID
+00A4: 0xA01E4F6C   ;  29: getEEFullMaxID
 00A8: 0xA01E5364   ;  2A: int *GetEELiteBlockAddress(short blocknum)
 ;0AC:              ;  2B: int GetEELiteBlockSizeVersion(uint32_t block, int *size, char *version)
 00B0: 0xA01E4A00   ;  2C: getEEFullBlockSizeVersion(int block, *buf1, *buf2)
@@ -56,15 +58,15 @@
 00C8: 0xA02821F0   ;  32: void PlaySound(long param1, long param2, long param3, long tone, long param5)
 00CC: 0xA0278B48   ;  33: PlaySound2
 00D0: 0xA0B5C1CC   ;  34: PlaySoundLoop
-;0D4:              ;  35: AlarmClockRing
-;0D8:              ;  36: void SLI_SetState(unsigned char state)
+;0D4:              ;  35: void AlarmClockRing()
+;0D8:              ;  36: void SLI_SetState(uint8_t state)
 00DC: 0xA027BFC8   ;  37: void Ringtones_SetState(unsigned char state)
 00E0: 0xA0556DE3   ;  38: int Registry_GetHMIKeyID(char *Keyword)
 00E4: 0xA05569F5   ;  39: Registry_SetResourcePath(int HMIKeyID, int Prio, WSHDR *Path)
 00E8: 0xA0554987   ;  3A: Registry_DeleteResourcePath(int HMIKeyID, int Prio)
 00EC: 0xA0FF98B5   ;  3B: MemChr
 00F0: 0xA025262C   ;  3C: int setfilesize(int FileHandler, unsigned int iNewFileSize, unsigned int *ErrorNumber)
-;0F4:              ;  3D: editOrNewTXTModule
+;0F4:              ;  3D: void editOrNewTXTModule(const char *file)
 00F8: 0xA0556481   ;  3E: Registry_GetResourcePathFromLevel(int HMIKeyID, int Prio, int *
 00FC: 0xA0966DC1   ;  3F: char *GetPaletteAdrByColorIndex_2(int ColorIndex)
 
@@ -74,9 +76,9 @@
 010C: 0xA091419B   ;  43: int IsUnlocked(void)
 0110: 0xA090E2B1   ;  44: TempLigntOn
 0114: 0xA006F241   ;  45: GetWavLen
-;118:              ;  46: HasNewSMS
-011C: 0xA029A1F5   ;  47: HasFlashSMS
-;120:              ;  48: ReadNewSMS
+;118:              ;  46: int HasNewSMS(void)
+011C: 0xA029B5F7   ;  47: int HasFlashSMS(void)
+;120:              ;  48: void ReadNewSMS()
 0124: 0xA02FF231   ;  49: ReadFlashSMS
 0128: 0xA027A9C0   ;  4A: short PlayFile(int flags, WSHDR *foldername, WSHDR *filename, int zero, int CepId, int Msg, const PLAYFILE_OPT *sfo)
 012C: 0xA0ABE9A4   ;  4B: StartMidlet
@@ -90,7 +92,7 @@
 0148: 0xA8D87CEC   ;  52: char *GetIlluminationDataTable()
 014C: 0xA0FF98D9   ;  53: int memcmp_2(void *m1,void *m2,int n)
 0150: 0xA02C4AD1   ;  54: StrToInt
-;154:              ;  55: SwitchVibraOnOff
+;154:              ;  55: void SwitchVibraOnOff()
 0158: 0xA006F131   ;  56: PlayVibra
 015C: 0xA0093388   ;  57: int IsTimerProc_2(GBSTMR *timer)
 0160: 0xA0FF9D34   ;  58: void zeromem_2(void *dest,int n)
@@ -109,7 +111,7 @@
 0190: 0xA096E0F7   ;  64: void GeneralFuncF1_2(int cmd)
 0194: 0xA09B448D   ;  65: EndCall
 0198: 0xA09B341B   ;  66: EndCallBusy
-019C: 0xA034F059   ;  67: IsDirectCallActive
+019C: 0xA02FC0A9   ;  67: int IsDirectCallActive(void)
 01A0: 0xA0304715   ;  68: GetScreenSaverRAM
 01A4: 0xA009B180   ;  69: void LockSched_2(void)
 01A8: 0xA009B26C   ;  6A: void UnlockSched_2(void)
@@ -124,13 +126,13 @@
 01C8: 0xA090BFDD   ;  72: SetCurrentSecondOfCall
 01CC: 0xA0D2921F   ;  73: int GetTypeOfCall(int type)
 01D0: 0xA02CC365   ;  74: SHORTCUTREC *GetShortcutRecordByName(char *szShortcutName)
-;1D4:              ;  75: int IsCanvasBufferSet(char canvas_id)
+01D4: 0xA029DBD1   ;  75: int IsCanvasBufferSet(char canvas_id)
 01D8: 0xA029DB81   ;  76: GetCanvasBufferPicPtr(char CanvasID)
 01DC: 0xA0967277   ;  77: void DrwObj_SetColor_2(DRWOBJ *drwobj, const char *pen, const char *brush)
 01E0: 0xA0911BD5   ;  78: GetTimeFormat
-01E4: 0xA0913331   ;  79: void DrawObject_2(DRWOBJ *)
+01E4: 0xA0913305   ;  79: void DrawObject2Layer(LCDLAYER *layer, DRWOBJ *drwobj)
 01E8: 0xA096B605   ;  7A: UpdateDisplayByLayerPtr(LCD_Layer *)
-;1EC:              ;  7B: GetProfileFilter
+;1EC:              ;  7B: int GetProfileFilter()
 01F0: 0xA01B0D67   ;  7C: unsigned int SetVibration(unsigned int power)
 01F4: 0xA0D283DF   ;  7D: IsIncognitoCall
 01F8: 0xA0D27A7D   ;  7E: Rand
@@ -139,12 +141,11 @@
 0200: 0xA05FE779   ;  80: int ShowCallList(int list, int zero)
 0204: 0xA0FFA12C   ;  81: HexToDec
 0208: 0xA054C70B   ;  82: GetCurrentTrackFilename
-;20C:              ;  83: GetPathOfFoundFile
+;20C:              ;  83: void *GetPathOfFoundFile()
 0210: 0xA02522F0   ;  84: int GetFileStats(const char *cFileName, void *StatBuffer, unsigned int *errornumber)
 0214: 0xA026F241   ;  85: StrCmpNoCase
 0218: 0xA01E4820   ;  86: __arm void EEFullReadBlock(int block, void *buf, int offset, int size, int cepid,)
 021C: 0xA01E4AB0   ;  87: _arm void EEFullWriteBlock(int block, void *buf, int offset, int size, int cepid, int msg);
-
 0220: 0xA006EF00   ;  88: char GetAccessoryType(void) <api>
 0224: 0xA0916470   ;  89: GetLangMesIntoWS
 0228: 0xA0251ED4   ;  8A: int GetFreeFlexSpace(int DriveNum, unsigned int *ErrorNumber)
@@ -164,8 +165,8 @@
 025C: 0xA006F261   ;  97: CreatePath
 0260: 0xA006F211   ;  98: void PlaySoundVibra(char SndNum, char VibraPower, unsigned int VibraDuration, char VibraIfOff)
 0264: 0xA027AC30   ;  99: int PlayMelodyInMem(char Unk_0x11,void *MelAddr,int MelSize,int unk2_0xFFFF,int Unk3_0,int Unk4_0)
-;268:              ;  9A: int ChangeVolume(unsigned char Volume)
-;26C:              ;  9B: RamAudioParamsAddr
+;268:              ;  9A: int ChangeVolume(uint8_t volume)
+;26C:              ;  9B: void *RamAudioParamsAddr()
 0270: 0xA0304C21   ;  9C: CloseScreensaver
 0274: 0xA02FF387   ;  9D: GetMissedEventsPtr
 0278: 0xA006F2B1   ;  9E: int GetMissedEventCount(unsigned int Event)
@@ -183,14 +184,14 @@
 02A4: 0xA0914983   ;  A9: void KbdLock()
 02A8: 0xA0A0FD8D   ;  AA: char *GetCurrentLocale()
 02AC: 0xA0002070   ;  AB: void loopback171()
-;2B0:              ;  AC: DrawText
-;2B4:              ;  AD: StrAnsi2Uni
-;2B8:              ;  AE: StrUni2Ansi
+;2B0:              ;  AC: void DrawText(const WSHDR *text, int x, int y, int font, int w, int h, int align, const char *pen, const char *brush, int inversion)
+;2B4:              ;  AD: void StrAnsi2Uni(const char *in, uint16_t *out)
+;2B8:              ;  AE: void StrUni2Ansi(const uint16_t *in, char *out)
 02BC: 0xA033C09D   ;  AF: Hex2Int
 
-;2C0:              ;  B0: DrawPicWithCanvas
+;2C0:              ;  B0: void DrawPicWithCanvas(int x, int y, int picture)
 02C4: 0xA006F101   ;  B1: DrawColorPicWithCanvas
-;2C8:              ;  B2: GetBuildCanvas
+;2C8:              ;  B2: void *GetBuildCanvas()
 02CC: 0xA006F551   ;  B3: long Seconds2iTime(int timeval)
 02D0: 0xA091074B   ;  B4: void GetDateTime(TDate *, TTime *)
 02D4: 0xA026DEDB   ;  B5: char GetWeek(TDate *)
@@ -205,20 +206,20 @@
 02F8: 0xA0060C91   ;  BE: RunScaner
 02FC: 0xA0063001   ;  BF: SpellTime
 
-;300:              ;  C0: MiniGPS
+;300:              ;  C0: uint32_t MiniGPS()
 0304: 0xA0060C51   ;  C1: RunDispatcher
-;308:              ;  C2: GetAllPatchesByInject
+;308:              ;  C2: void GetAllPatchesByInject()
 030C: 0xA006F091   ;  C3: ProcessFiles
 0310: 0xA0060C01   ;  C4: GetBuffer
 0314: 0xA02FF32F   ;  C5: char IsIdleUiOnTop()
 0318: 0xA01A86B4   ;  C6: char GetAkkuCapacity()
-;31C:              ;  C7: SWI_C7 <elfpack>
+;31C:              ;  C7: void CallLibFunByNumber(int func_id)
 0320: 0xA8D836D6   ;  C8: unsigned short *RamCap()
 0324: 0xA8D836FA   ;  C9: RamLS
 0328: 0xA8EADA2A   ;  CA: RAMNET *RamNet()
 032C: 0xA8DF7974   ;  CB: RamRingtoneStatus
 0330: 0xA8E684B4   ;  CC: RamMissedCalls
-;334:              ;  CD: RamMissedSMS
+;334:              ;  CD: char *RamMissedSMS()
 0338: 0xA8DA850C   ;  CE: RamDateTime
 033C: 0xA8F124C0   ;  CF: RamAlarm
 
@@ -230,10 +231,10 @@
 0354: 0xA8DB3CAC   ;  D5: RamIsLocked
 0358: 0xA8E2B950   ;  D6: RamNetOnline
 035C: 0xA8E2CA2C   ;  D7: RamScreenBrightness
-;360:              ;  D8: RamMenuAnywhere
-;364:              ;  D9: RamShutdownMode
+;360:              ;  D8: void *RamMenuAnywhere()
+;364:              ;  D9: void *RamShutdownMode()
 0368: 0xA8E2CAC8   ;  DA: RamIsShutdown
-;36C:              ;  DB: int *RamIsNotOnMainscreen()
+036C: 0xA8F10D0C   ;  DB: int *RamIsNotOnMainscreen()
 0370: 0xA8E4BAB8   ;  DC: int *RamRandSeed()
 0374: 0xA899F2BC   ;  DD: RamCurrentTrack
 0378: 0xA8DF6D00   ;  DE: RamIsSimPresent
@@ -241,8 +242,8 @@
 
 0380: 0xA8DA8698   ;  E0: char *RamScreenBuffer()
 0384: 0xA8EBD7A8   ;  E1: unsigned int RamMPlayer_CtrlCode()
-;388:              ;  E2: RamKeyBuffer
-;38C:              ;  E3: RamProfileNum
+;388:              ;  E2: char *RamKeyBuffer()
+;38C:              ;  E3: char *RamProfileNum()
 0390: 0xAC000000   ;  E4: FreeRAM
 0394: 0x0000123D   ;  E5: LP_MonthsShort
 0398: 0x00000260   ;  E6: Pic_Big0
@@ -250,7 +251,7 @@
 03A0: 0x00000800   ;  E8: Pic_Extra
 03A4: 0x00000810   ;  E9: Pic_Profiles
 03A8: 0x00000818   ;  EA: Pic_Vibra
-;3AC:              ;  EB: Pic_Call
+;3AC:              ;  EB: int PIT_Pic_Call()
 03B0: 0x00000800   ;  EC: Pic_AdvNet
 03B4: 0x00001137   ;  ED: LP_MonthsLong
 03B8: 0x000003EB   ;  EE: LP_Weekdays
@@ -258,19 +259,19 @@
 
 03C0: 0x00001200   ;  F0: Pic_AccuGraph
 03C4: 0xA0301A9D   ;  F1: void *BuildCanvas()
-;3C8:              ;  F2: lpRAM_PIT
-;3CC:              ;  F3: RAM_PIT_Cap
-;3D0:              ;  F4: Pic_LANI
+;3C8:              ;  F2:
+;3CC:              ;  F3:
+;3D0:              ;  F4: int PIT_Pic_Lani()
 03D4: 0xA8DA85EC   ;  F5: Ram_LCD_Overlay_Layer
 03D8: 0xA8E2D070   ;  F6: RAM_LCD_Layer_Base_Ptr
-;3DC:              ;  F7:
-;3E0:              ;  F8: Additional_PIT_address
-;3E4:              ;  F9: Additional_PIT_start
-;3E8:              ;  FA: Additional_PIT_end
-;3EC:              ;  FB:
-;3F0:              ;  FC: PictureRelocationTable
-;3F4:              ;  FD: PictureRelocationBase
-;3F8:              ;  FE: NextPictureMagic
+;3DC:              ;  F7: RAP_LCDLAYER_LIST *RamLcdRapLayersList()
+;3E0:              ;  F8: void *Additional_PIT_address()
+;3E4:              ;  F9: uint32_t Additional_PIT_start()
+;3E8:              ;  FA: uint32_t Additional_PIT_end()
+;3EC:              ;  FB: void *ShortcutsTableAddr()
+;3F0:              ;  FC: void *PictureRelocationTableAddr()
+;3F4:              ;  FD: uint32_t PictureRelocationBaseAddr()
+;3F8:              ;  FE: uint32_t NextPictureMagicValue()
 03FC: 0xA0074000   ;  FF: unsigned int AddrLibrary()
 
 0400: 0xA0092A94   ; 100: void GBS_SendMessage(int cepid_to, int msg, ...)
@@ -283,10 +284,10 @@
 041C: 0xA0965773   ; 107: int CreateCSM(const CSM_DESC *,void *,int)
 0420: 0xA0965785   ; 108: CSM_RAM *FindCSMbyID(int id)
 0424: 0xA0965841   ; 109: void DoIDLE(void)
-;428:              ; 10A: void *GetConfig(unsigned int id)
+;428:              ; 10A: void *GetConfig(uint32_t id)
 ;42C:              ; 10B: void *GetMinAdrScan()
 ;430:              ; 10C: void *GetMaxAdrScan()
-;434:              ; 10D: unsigned short *GetCI()
+;434:              ; 10D: uint16_t *GetCI()
 0438: 0xA0FF9DCE   ; 10E: void Vibration(unsigned int power, unsigned int duration)
 043C: 0xA029AFD5   ; 10F: void freeUSSD()
 
@@ -393,7 +394,7 @@
 05BC: 0xA0516954   ; 16F: int GetTypeOfAB_UNPRES_ITEM(int)
 
 05C0: 0xA094B581   ; 170: int MakeVoiceCall(const char *number,int _0x10, int _0x20C0)
-;5C4:              ; 171: void SUBPROC(void *,...)
+;5C4:              ; 171: void SUBPROC(void *callback, ...)
 ;5C8:              ; 172: void REDRAW(void)
 05CC: 0xA0A46C01   ; 173: int socket(int af,int type,int protocol)
 05D0: 0xA0A470F9   ; 174: int connect(int sock,SOCK_ADDR *,int name_length)
@@ -438,17 +439,17 @@
 0664: 0xA097300F   ; 199: void SetMenuItemIconArray(void *gui,void *item,const int *icons)
 0668: 0xA09729AF   ; 19A: void SetMenuItemText(void *gui,void *item,WSHDR *text,int item_n)
 066C: 0xA0A0F1ED   ; 19B: void EDIT_SetFocus(void *gui, int item)
-;670:              ; 19C: void SEQKILLER(void *data, void(*next_in_seq)(void *), void *data_to_kill)
+;670:              ; 19C: void SEQKILLER(void *data, void (*next_in_seq)(void *), void *data_to_kill)
 0674: 0xA01D1178   ; 19D: long long getCpuUsedTime_if_ena(void)
 0678: 0xA01D111C   ; 19E: void StartCpuUsageCount(void)
 067C: 0xA01325E9   ; 19F: int inflateInit2_(z_streamp strm, int windowBits,const char *version, int stream_size)
 
 0680: 0xA013271F   ; 1A0: int inflate(z_streamp strm, int flush)
 0684: 0xA013355B   ; 1A1: int inflateEnd(z_streamp strm)
-;688:              ; 1A2: int ActivateDialUpProfile(unsigned int cep_id,int profile_num)
+;688:              ; 1A2: int ActivateDialUpProfile(uint32_t cepid, int profile_id)
 ;68C:              ; 1A3: int GetCurrentGPRSProfile(void)
 ;690:              ; 1A4: int GetDisconnectTime(void)
-;694:              ; 1A5: void RegisterCepIdForCurProfile(unsigned int cep_id,int profile_num,unsigned int unk)
+;694:              ; 1A5: void RegisterCepIdForCurProfile(uint32_t cepid, int profile_id, uint32_t is_gprs)
 0698: 0xA0093388   ; 1A6: int IsTimerProc(GBSTMR *)
 069C: 0xA09501D5   ; 1A7: char *Get_CC_NC()
 06A0: 0xA0136849   ; 1A8: png_structp png_create_read_struct_2(png_const_charp user_png_ver, png_voidp error_ptr, png_error_ptr error_fn, png_error_ptr warn_fn)
@@ -468,10 +469,10 @@
 06D4: 0x00000001   ; 1B5: int isnewSGold()
 06D8: 0xA0A48401   ; 1B6: int async_gethostbyname(const char *host_name,int ****DNR_RES,int *DNR_ID)
 06DC: 0xA09910C9   ; 1B7: unsigned int str2ip(const char *)
-;6E0:              ; 1B8: void *EXT_TOP(void)
-;6E4:              ; 1B9: void *PNG_TOP(void)
+;6E0:              ; 1B8: TREGEXPLEXT *EXT_TOP(void)
+;6E4:              ; 1B9: PNGTOP_DESC *PNG_TOP(void)
 ;6E8:              ; 1BA: void *LIB_TOP(void)
-;6EC:              ; 1BB: void *DATA_N_SFB(void)
+;6EC:              ; 1BB: SFN_DATA *DATA_N_SFB(void)
 06F0: 0xA0F3C51F   ; 1BC: void SHA1_Init(SHA_CTX *c)
 06F4: 0xA0F3C203   ; 1BD: void SHA1_Update(SHA_CTX *c, const void *data, unsigned long len)
 06F8: 0xA0F3C3FF   ; 1BE: void SHA1_Final(char *md, SHA_CTX *c)
@@ -493,6 +494,7 @@
 0734: 0xA0A08C5D   ; 1CD: void SetBrushColorToEditCOptions(EDITC_OPTIONS *ec_options, int brush)
 0738: 0xA0A08D45   ; 1CE: void CopyOptionsToEditControl(EDITCONTROL *ec,EDITC_OPTIONS *ec_options)
 073C: 0xA04E6DA3   ; 1CF: TREGEXPLEXT *get_regextpnt_by_uid(int uid)
+
 0740: 0xA04E6C5B   ; 1D0: int GetExtUid_ws(WSHDR * ext)
 0744: 0xA0A0F931   ; 1D1: void EDIT_RemoveEditControl(void *gui,int n)
 0748: 0xA0A0F93D   ; 1D2: void EDIT_InsertEditControl(void *gui,int n,EDITCONTROL *)
@@ -519,19 +521,19 @@
 0798: 0xA0971D8D   ; 1E6: void Menu_SetItemCountDyn(void *gui, int n)
 079C: 0xA0AEFB04   ; 1E7: char *GetLastJavaApplication()
 07A0: 0xA09FAA7C   ; 1E8: int IsNoJava()
-;7A4: elfpack      ; 1E9: IMGHDR *CreateIMGHDRFromPngFile(const char *fname, int type)
+;7A4:              ; 1E9: IMGHDR *CreateIMGHDRFromPngFile(const char *path, int type)
 07A8: 0xA096C12B   ; 1EA: int GetMaxDynIcon(void)
 07AC: 0xA8E4BF7E   ; 1EB: char *RAM_IMSI()
 07B0: 0xA096C12F   ; 1EC: void FreeDynIcon(int picture)
 07B4: 0xA096C28F   ; 1ED: int IsDynIconBusy(int picture)
-;7B8:              ; 1EE: ProgressCalculate(int current, int total)
+;7B8:              ; 1EE: int ProgressCalculate(int current, int total)
 07BC: 0xA096C191   ; 1EF: void SetDynIcon(int picture,IMGHDR *img,char *bitmap)
 
-;7C0:              ; 1F0: filecopy
-;7C4:              ; 1F1: filecopy_op_announce
+;7C0:              ; 1F0: int ExplorerCopyFile(const WSHDR *from, const WSHDR *to, int overwrite, char transfer_id, uint32_t *errp)
+;7C4:              ; 1F1: int ExplorerSetTransferState(char transfer_id, int state)
 07C8: 0xA01DE84C   ; 1F2: devmenu_config_IsCheckboxOff
 07CC: 0xA00A8954   ; 1F3: unsigned int GetSessionAge()
-07D0: 0xA8E4C343   ; 1F4: char *RamServiceProviderName()
+07D0: 0xA8E4C344   ; 1F4: char *RamServiceProviderName(void)
 07D4: 0xA0FFA19D   ; 1F5: int sscanf(const char *, const char *, ...)
 07D8: 0xA096C2DB   ; 1F6: IMGHDR *GetPitAdrBy0xE200Symbol(int uni_symbol)
 07DC: 0xA006F501   ; 1F7: long GetFileSize(char *Filename)
@@ -560,6 +562,7 @@
 0834: 0xA0A0F8D5   ; 20D: __thumb void EDIT_GetTime(void *gui,int n,TTime *tt);
 0838: 0xA0A08FD3   ; 20E: __thumb int ConstructEditTime(EDITCONTROL *EditControl,TTime *time);
 083C: 0xA0A08EB9   ; 20F: __thumb int ConstructEditDate(EDITCONTROL *EditControl,TDate *date);
+
 0840: 0xA096DF55   ; 210: int GetCurGuiID(void)
 0844: 0x000061E8   ; 211: GBS_Cmd_4209_RefreshScreensaver
 0848: 0xA0AF8130   ; 212: __swi __arm int CardExplGetCurItem(void *csm);
@@ -576,9 +579,12 @@
 0874: 0xA0949A99   ; 21D: __thumb int GSMTXT_Decode(WSHDR *dest,void *pkt,int len,int encoding_type);
 0878: 0xA096E18F   ; 21E: __thumb void FocusGUI(int id);
 087C: 0xA096E19F   ; 21F: __thumb void UnfocusGUI(void);
+
 0880: 0xA0521C4F   ; 220: int IsSliderClosed(void)
 0884: 0xA01D0928   ; 221: SetCpuClockLow(2)
 0888: 0xA01D0910   ; 222: SetCpuClockTempHi(2)
+088C: 0xA054C573   ; 223: int IsMediaPlayerInBackground()
+0890: 0xA054CE5B   ; 224: void CloseMediaPlayer()
 0894: 0xA027B2DC   ; 225: __arm int PlayMelody_ChangeVolume(int handle,int volume);
 0898: 0xA027BD8C   ; 226: __arm int PlayMelody_StopPlayback(int handle);
 089C: 0xA027BE2C   ; 227: __arm int PlayMelody_PausePlayback(int handle);
@@ -590,36 +596,50 @@
 08B4: 0xA02D52B1   ; 22D: pdcache_setval(char *new_value, char cachetype, 0, char *pd_entry_identifier)
 08B8: 0xA05493A7   ; 22E: int OpenExplorer(NativeExplorerData *data)
 08BC: 0xA8DA855C   ; 22F: TDateTimeSettings *RamDateTimeSettings
+
 08C0: 0xA09106D9   ; 230: int GetTimeZoneShift(int param1, int param2, int timeZone)
 08C4: 0xA8DA8504   ; 231: TAppointment *RamAppointment
 08C8: 0xA0092848   ; 232: GBS_DestroyMessage(GBS_MSG *)
 08CC: 0xA061BF73   ; 233: void GetAllEmail()
-;8D0:              ; 238: int GetLunarDate(const TDate *date, TDate *lunar_date)
-;8D4:              ; 239: int GetLunarYearID(int year)
-;8D8:              ; 23A: int GetLunarAnimal(int year)
+;8D0:              ; 234: int GetLunarDate(const TDate *date, TDate *lunar_date)
+;8D4:              ; 235: int GetLunarYearID(int year)
+;8D8:              ; 236: int GetLunarAnimal(int year)
+;8DC:              ; 237: char *RamIconBar()
+08E0: 0xA09515C7   ; 238: void SendAutoUSSDack(void)
+08E4: 0xA01E4ECC   ; 239: int EEFullDeleteBlock(uint32_t block, int cepid, int msg)
+08E8: 0xA01E5038   ; 23A: int EEFullCreateBlock(uint32_t block, int size, int version, int cepid, int msg)
 ;8EC:              ; 23B: void DisableIconBar(int disable)
-;8F0:              ; 23C: int SetCurrentGPRSProfile(int profile)
+;8F0:              ; 23C: int SetCurrentGPRSProfile(int profile_id)
 08F4: 0xA0F39299   ; 23D: void MD5_Init(MD5_CTX *c)
 08F8: 0xA0F38F09   ; 23E: void MD5_Update(MD5_CTX *c, const void *data, unsigned long len)
 08FC: 0xA0F391A1   ; 23F: void MD5_Final(unsigned char *md, MD5_CTX *c)
+
 0900: 0xA0F39C29   ; 240: char *MD5_Hash(const unsigned char *data, unsigned long n, unsigned char *
 0904: 0xA09108F7   ; 241: void SetDateTime(TDate *, TTime *)
-0920: 0xA8D86BCE   ; 248: char *RamFormatTrack()
+;908:              ; 242: void gb2ws(WSHDR *destination, const char *source, int size)
+;90C:              ; 243: void ws2gb(const WSHDR *source, char *destination, int size)
+0910: 0xA0E71FF1   ; 244: int Base64Encode(void *inbuf, int insize, void *outbuf, int outsize)
+0914: 0xA0E720A1   ; 245: int Base64Decode(char *inbuf, int insize, void *outbuf, int outsize, char *_null, int *unk5)
+0918: 0xA05B18A7   ; 246: int GetFileProp(FILE_PROP *props, const WSHDR *file, const WSHDR *path)
 091C: 0xA09981C9   ; 247: NetOff();
+0920: 0xA8D86BCE   ; 248: char *RamFormatTrack()
 0924: 0xA8D86E36   ; 249: char *RamFreq()
 0928: 0xA8D86FEE   ; 24A: char *RamChannel()
-092C: 0xA097359E   ; 24B: void SetMenuSearchCallBack(void *gui, MenuSearchCallBack proc);
-0930: 0xA02EDE58   ; 24C: int GetPeripheryState (int device, int check_state);
+092C: 0xA097359F   ; 24B: void SetMenuSearchCallBack(void *gui, const MenuSearchCallBack callback)
+0930: 0xA02EDE59   ; 24C: int GetPeripheryState(int device, int check)
 0934: 0xA027BE8C   ; 24D: int PlayMelody_SetPosition(int handle, int pos_ms);
 0938: 0xA02CA510   ; 24E: void* GetPlayObjById(int handle);
 093C: 0xA0929B1C   ; 24F: int GetPlayObjPosition(void *playobj_3D0, int *pos_ms);
+
 0940: 0xA09298B4   ; 250: int GetPlayObjDuration(void *playobj_3D0, int *pos_ms);
-094C: 0xA8E63BE2   ; 253: char *RamLastCallNum();
+;944:              ; 251: void *RamSizeOfPart()
+;948:              ; 252: int *RamSizeOfReceivedOrSentFile()
+094C: 0xA8E688DA   ; 253: char *RamLastCallNum()
 0950: 0xA05493A7   ; 254: int StartNativeExplorer(NativeExplorerData* data);
-0954: 0xA0974D02   ; 255: void MenuSetUserPointer(void *gui,void *user_pointer);
+0954: 0xA0974D03   ; 255: void MenuSetUserPointer(void *gui, void *user_pointer)
 ;958:              ; 256: const char *RamNameOfReceivedOrSentFile()
 095C: 0xA0935578   ; 257: isSendReceiveFile();
-0960: 0xA096BB20   ; 258: int CalcBitmapSize(short w,short h, char typy);
+0960: 0xA096BB21   ; 258: int CalcBitmapSize(short w, short h, char type)
 0964: 0xA09A00D8   ; 259: HObj Obs_CreateObject(int uid_in, int uid_out, int prio, int msg_callback, int emb4, int sync,unsigned int *ErrorNumber);
 0968: 0xA0B95748   ; 25A: int Obs_DestroyObject(HObj hObj);
 096C: 0xA099E0BC   ; 25B: int Obs_SetInput_File (HObj hObj, int unk_zero, WSHDR *path);
@@ -627,10 +647,42 @@
 0974: 0xA0A64854   ; 25D: int Obs_SetOutputImageSize (HObj hObj, short w, short h);
 0978: 0xA092C9A8   ; 25E: int Obs_Start(HObj hObj);
 097C: 0xA0A659CC   ; 25F: int Obs_Output_GetPictstruct(HObj hObj, IMGHDR **img);
+
 0980: 0xA0A6558C   ; 260: int Obs_Graphics_SetClipping(HObj hObj, short x, short y, short w, short h);
 0984: 0xA0A64F9C   ; 261: int Obs_SetRotation(HObj hObj, int angle);
 0988: 0xA092C608   ; 262: int Obs_GetInfo (HObj hObj, int unk_0or1);
 098C: 0xA0A64D48   ; 263: int Obs_SetScaling (HObj hObj, int unk5);
+0990: 0xA09A1758   ; 264: int Obs_TranslateMessageGBS(const GBS_MSG *msg, const OBSevent *handlers)
+0994: 0xA092CCFC   ; 265: int Obs_Pause(HObj obs)
+0998: 0xA092D058   ; 266: int Obs_Resume(HObj obs)
+099C: 0xA092CE84   ; 267: int Obs_Stop(HObj obs)
+09A0: 0xA092C81C   ; 268: int Obs_Prepare(HObj obs)
+09A4: 0xA0B15FB0   ; 269: int Obs_SetRenderOffset(HObj obs, short x, short y)
+09A8: 0xA0929A58   ; 26A: int Obs_SetPosition(HObj obs, int position)
+;9AC:              ; 26B: int Obs_Mam_SetPurpose(HObj obs, char purpose)
+09B0: 0xA0A5CB84   ; 26C: int Obs_Sound_SetVolumeEx(HObj obs, char volume, char delta)
+09B4: 0xA0A5D860   ; 26D: int Obs_Sound_GetVolume(HObj obs, char *volume)
+09B8: 0xA0A5D09C   ; 26E: int Obs_Sound_SetPurpose(HObj obs, int purpose)
+;9BC:              ; 26F: int Obs_Sound_SetAMRFormat(HObj obs, int format)
+
+;9C0:              ; 270: int Obs_Sound_SetAMRDTX(HObj obs, int dtx)
+;9C4:              ; 271: int Obs_Sound_SetNofChannels(HObj obs, int num_channels)
+;9C8:              ; 272: int Obs_Sound_SetAMRMode(HObj obs, int data_rate)
+;9CC:              ; 273: int Obs_Sound_SetFIsRecording(HObj obs, int is_recording)
+;9D0:              ; 274: int Obs_Sound_SetMaxFileSize(HObj obs, int max_file_size)
+;9D4:              ; 275: int Obs_Sound_SetRecordingMode(HObj obs, int recording_mode)
+;9D8:              ; 276: int Obs_SetOutput_File(HObj obs, const WSHDR *filename)
+;9DC:              ; 277: int Obs_SetOutput_Uid(HObj obs, int uid)
+;9E0:              ; 278: int Obs_Sound_SetBitrate(HObj obs, int bitrate)
+;9E4:              ; 279:
+09E8: 0xA099E168   ; 27A: int Obs_SetInput_Memory(HObj obs, int unk, char *buf, int len)
+09EC: 0xA0929D50   ; 27B: int Obs_SetCSM(HObj obs, CSM_RAM *csm)
+;9F0:              ; 27C:
+;9F4:              ; 27D:
+;9F8:              ; 27E:
+;9FC:              ; 27F:
+
+;A00:              ; 280:
 0A04: 0xA8E6F048   ; 281: char *RamIsRunJava();
 0A08: 0xA8E52400   ; 282: char *RamIsRunCamera():
 0A0C: 0xA0545655   ; 283: int runMidletLinkablely(const char *midlet_name, WSHDR *filename)
@@ -652,6 +704,7 @@
 0A48: 0xA8F124C4   ; 292: __swi __arm char *RamIsAlarmAutorepeatOn()
 0A4C: 0xA8F124CC   ; 293: __swi __arm char *RamAlarmclockHour()
 0A50: 0xA8F124CD   ; 294: __swi __arm char *RamAlarmclockMinute()
+;A54:              ; 295:
 0A58: 0xA028A5AD   ; 296: __swi __arm void getProfileNameByN(WSHDR *ws, int n, int _0)
 0A5C: 0xA8F0B170   ; 297: __swi __arm char *RamIsSoundRecord()
 0A60: 0xA8F0B1CC   ; 298: __swi __arm char *RamIsSoundRecordQuality()
@@ -664,8 +717,8 @@
 0A7C: 0xA8DA285C   ; 29F: char *RamIsBTHeadsetConnected()
 
 0A80: 0xA029E954   ; 2A0: int GetAlarmclockState(int state)
-;0A84: 0x ; 2A1:
-;0A88: 0x ; 2A2:
+;A84:              ; 2A1:
+;A88:              ; 2A2:
 0A8C: 0xA0971E31   ; 2A3: __swi __arm void UpdateMenuCursorItem(void *gui, int n)
 0A90: 0xA096EC93   ; 2A4: void *GetMenuGUI(void *malloc_adr, void *mfree_adr)
 0A94: 0xA0975BC1   ; 2A5: void *GetMultiLinesMenuGUI(void *malloc_adr, void *mfree_adr)
@@ -716,7 +769,7 @@
 
 0B40: 0xA026DDCD   ; 2D0: __swi __arm int GetDaysFromMonth(TDate *date)
 0B44: 0xA026DDAD   ; 2D1: __swi __arm int IsLeapYear(TDate *date)
-;B48:              ; 2D2: __swi __thumb StartNativeBrowserCore()
+;B48:              ; 2D2: void StartNativeBrowserCore()
 0B4C: 0xA05259E0   ; 2D3: __swi __arm int GetFilledNAbDataCount(NativeAbData *nab)
 0B50: 0xA0524F88   ; 2D4: __swi __arm void *GetDataFromNAbData(NativeAbData *nab, int n)
 0B54: 0xA0951F33   ; 2D5: __swi __arm void UnpackNumPkt(PKT_NUM *pkt, char *buf, int maxlen)
@@ -746,6 +799,24 @@
 0BB0: 0xA01F0C20   ; 2EC: __swi __arm int i2c_transfer(I2C_MSG *msg)
 0BB4: 0xA01F0C74   ; 2ED: __swi __arm int i2c_receive(I2C_MSG *msg)
 ;BB8:              ; 2EE: int elfclose(void *ex)
+;BBC:              ; 2EF: int dlopen(const char *name)
+
+;BC0:              ; 2F0: void *dlsym(int handle, const char *name)
+;BC4:              ; 2F1: int dlclose(int handle)
+;BC8:              ; 2F2: int setenv(const char *name, const char *value, int replace)
+;BCC:              ; 2F3: int unsetenv(const char *name)
+;BD0:              ; 2F4: char *getenv(const char *name)
+;BD4:              ; 2F5: int clearenv(void)
+;BD8:              ; 2F6: char **getBaseEnviron()
+;BDC:              ; 2F7: const char *dlerror()
+;BE0:              ; 2F8: int dlclean_cache()
+;BE4:              ; 2F9: void *SHARED_TOP()
+;BE8:              ; 2FA:
+;BEC:              ; 2FB:
+;BF0:              ; 2FC:
+;BF4:              ; 2FD:
+;BF8:              ; 2FE:
+;BFC:              ; 2FF:
 
 0C00: 0xA00A2420   ; 300: __arm NU_Create_Task
 0C04: 0xA00A253C   ; 301: __arm NU_Delete_Task
@@ -766,50 +837,50 @@
 
 0C40: 0xA00A3090   ; 310: __arm NU_Create_Mailbox
 0C44: 0xA00A30BC   ; 311: __arm NU_Delete_Mailbox
-;C48:              ; 312: __arm NU_Reset_Mailbox
+;C48:              ; 312: int NU_Reset_Mailbox(NU_MAILBOX *mailbox)
 0C4C: 0xA00A30DC   ; 313: __arm NU_Send_To_Mailbox
-;C50:              ; 314: __arm NU_Broadcast_To_Mailbox
+;C50:              ; 314: int NU_Broadcast_To_Mailbox(NU_MAILBOX *mailbox, void *message, unsigned long suspend)
 0C54: 0xA00A3140   ; 315: __arm NU_Receive_From_Mailbox
-;C58:              ; 316: __arm NU_Established_Mailboxes
-;C5C:              ; 317: __arm NU_Mailbox_Information
-;C60:              ; 318: __arm NU_Mailbox_Pointers
+;C58:              ; 316: unsigned long NU_Established_Mailboxes(void)
+;C5C:              ; 317: int NU_Mailbox_Information(NU_MAILBOX *mailbox, CHAR *name, OPTION *suspend_type, OPTION *message_present, unsigned long *tasks_waiting, NU_TASK **first_task)
+;C60:              ; 318: unsigned long NU_Mailbox_Pointers(NU_MAILBOX **pointer_list, unsigned long maximum_pointers)
 0C64: 0xA00A60D4   ; 319: __arm NU_Create_Queue
 0C68: 0xA00A6174   ; 31A: __arm NU_Delete_Queue
-;C6C:              ; 31B: __arm NU_Reset_Queue
-;C70:              ; 31C: __arm NU_Send_To_Front_Of_Queue
+;C6C:              ; 31B: int NU_Reset_Queue(NU_QUEUE *queue)
+;C70:              ; 31C: int NU_Send_To_Front_Of_Queue(NU_QUEUE *queue, void *message, unsigned long size, unsigned long suspend)
 0C74: 0xA00A6194   ; 31D: __arm NU_Send_To_Queue
-;C78:              ; 31E: __arm NU_Broadcast_To_Queue
+;C78:              ; 31E: int NU_Broadcast_To_Queue(NU_QUEUE *queue, void *message, unsigned long size, unsigned long suspend)
 0C7C: 0xA00A6238   ; 31F: __arm NU_Receive_From_Queue
 
 0C80: 0xA00A62E8   ; 320: __arm NU_Established_Queues
 0C84: 0xA00A63A0   ; 321: __arm NU_Queue_Information
 0C88: 0xA00A62FC   ; 322: __arm NU_Queue_Pointers
-;C8C:              ; 323: __arm NU_Create_Pipe
-;C90:              ; 324: __arm NU_Delete_Pipe
-;C94:              ; 325: __arm NU_Reset_Pipe
-;C98:              ; 326: __arm NU_Send_To_Front_Of_Pipe
-;C9C:              ; 327: __arm NU_Send_To_Pipe
-;CA0:              ; 328: __arm NU_Broadcast_To_Pipe
-;CA4:              ; 329: __arm NU_Receive_From_Pipe
-;CA8:              ; 32A: __arm NU_Established_Pipes
-;CAC:              ; 32B: __arm NU_Pipe_Information
-;CB0:              ; 32C: __arm NU_Pipe_Pointers
+;C8C:              ; 323: int NU_Create_Pipe(NU_PIPE *pipe, CHAR *name, void *start_address, unsigned long pipe_size, OPTION message_type, unsigned long message_size, OPTION suspend_type)
+;C90:              ; 324: int NU_Delete_Pipe(NU_PIPE *pipe)
+;C94:              ; 325: int NU_Reset_Pipe(NU_PIPE *pipe)
+;C98:              ; 326: int NU_Send_To_Front_Of_Pipe(NU_PIPE *pipe, void *message, unsigned long size, unsigned long suspend)
+;C9C:              ; 327: int NU_Send_To_Pipe(NU_PIPE *pipe, void *message, unsigned long size, unsigned long suspend)
+;CA0:              ; 328: int NU_Broadcast_To_Pipe(NU_PIPE *pipe, void *message, unsigned long size, unsigned long suspend)
+;CA4:              ; 329: int NU_Receive_From_Pipe(NU_PIPE *pipe, void *message, unsigned long size, unsigned long *actual_size, unsigned long suspend)
+;CA8:              ; 32A: unsigned long NU_Established_Pipes(void)
+;CAC:              ; 32B: int NU_Pipe_Information(NU_PIPE *pipe, CHAR *name, void **start_address, unsigned long *pipe_size, unsigned long *available, unsigned long *messages, OPTION *message_type, unsigned long *message_size, OPTION *suspend_type, unsigned long *tasks_waiting, NU_TASK **first_task)
+;CB0:              ; 32C: unsigned long NU_Pipe_Pointers(NU_PIPE **pointer_list, unsigned long maximum_pointers)
 0CB4: 0xA00A39C0   ; 32D: __arm NU_Create_Semaphore
 0CB8: 0xA00A39F8   ; 32E: __arm NU_Delete_Semaphore
-;CBC:              ; 32F: __arm NU_Reset_Semaphore
+;CBC:              ; 32F: int NU_Reset_Semaphore(NU_SEMAPHORE *semaphore, unsigned long initial_count)
 
 0CC0: 0xA00A3A18   ; 330: __arm NU_Obtain_Semaphore
 0CC4: 0xA00A3A68   ; 331: __arm NU_Release_Semaphore
-;CC8:              ; 332: __arm NU_Established_Semaphores
-;CCC:              ; 333: __arm NU_Semaphore_Information
-;CD0:              ; 334: __arm NU_Semaphore_Pointers
+;CC8:              ; 332: unsigned long NU_Established_Semaphores(void)
+;CCC:              ; 333: int NU_Semaphore_Information(NU_SEMAPHORE *semaphore, CHAR *name, unsigned long *current_count, OPTION *suspend_type, unsigned long *tasks_waiting, NU_TASK **first_task)
+;CD0:              ; 334: unsigned long NU_Semaphore_Pointers(NU_SEMAPHORE **pointer_list, unsigned long maximum_pointers)
 0CD4: 0xA00A2F2C   ; 335: __arm NU_Create_Event_Group
 0CD8: 0xA00A2F48   ; 336: __arm NU_Delete_Event_Group
 0CDC: 0xA00A2F68   ; 337: __arm NU_Set_Events
 0CE0: 0xA00A2F9C   ; 338: __arm NU_Retrieve_Events
-;CE4:              ; 339: __arm NU_Established_Event_Groups
-;CE8:              ; 33A: __arm NU_Event_Group_Information
-;CEC:              ; 33B: __arm NU_Event_Group_Pointers
+;CE4:              ; 339: unsigned long NU_Established_Event_Groups(void)
+;CE8:              ; 33A: int NU_Event_Group_Information(NU_EVENT_GROUP *group, CHAR *name, unsigned long *event_flags, unsigned long *tasks_waiting, NU_TASK **first_task)
+;CEC:              ; 33B: unsigned long NU_Event_Group_Pointers(NU_EVENT_GROUP **pointer_list, unsigned long maximum_pointers)
 0CF0: 0xA00A3AF0   ; 33C: __arm NU_Control_Signals
 0CF4: 0xA00A3B10   ; 33D: __arm NU_Receive_Signals
 0CF8: 0xA00A3B30   ; 33E: __arm NU_Register_Signal_Handler
@@ -833,7 +904,7 @@
 0D3C: 0xA00A8084   ; 34F: __arm NU_Local_Control_Interrupts
 
 0D40: 0xA00A809C   ; 350: __arm NU_Restore_Interrupts
-;D44:              ; 351: __arm NU_Setup_Vector
+;D44:              ; 351: void *NU_Setup_Vector(INT vector, void *new_vector)
 0D48: 0xA00A232C   ; 352: __arm NU_Register_LISR
 0D4C: 0xA00A27B8   ; 353: __arm NU_Activate_HISR
 0D50: 0xA00A24CC   ; 354: __arm NU_Create_HISR
@@ -856,22 +927,32 @@
 0D90: 0xA00A8954   ; 364: __arm NU_Retrieve_Clock
 0D94: 0xA00A6528   ; 365: __arm NU_Release_Information
 0D98: 0xA00A6528   ; 366: __arm NU_License_Information
-;D9C:              ; 367: __arm NU_Disable_History_Saving
-;DA0:              ; 368: __arm NU_Enable_History_Saving
-;DA4:              ; 369: __arm NU_Make_History_Entry
-;DA8:              ; 36A: __arm NU_Retrieve_History_Entry
-;DAC:              ; 36B: __arm NU_Create_Driver
-;DB0:              ; 36C: __arm NU_Delete_Driver
-;DB4:              ; 36D: __arm NU_Request_Driver
-;DB8:              ; 36E: __arm NU_Resume_Driver
-;DBC:              ; 36F: __arm NU_Suspend_Driver
-
-;DC0:              ; 370: __arm NU_Established_Drivers
-;DC4:              ; 371: __arm NU_Driver_Pointers
-;DC8:              ; 372: __arm NU_IS_SUPERVISOR_MODE
-;DCC:              ; 373: __arm NU_SUPERVISOR_MODE
+;D9C:              ; 367: void NU_Disable_History_Saving(void)
+;DA0:              ; 368: void NU_Enable_History_Saving(void)
+;DA4:              ; 369: void NU_Make_History_Entry(unsigned long param1, unsigned long param2, unsigned long param3)
+;DA8:              ; 36A: int NU_Retrieve_History_Entry(DATA_ELEMENT *id, unsigned long *param1, unsigned long *param2, unsigned long *param3, unsigned long *time, NU_TASK **task, NU_HISR **hisr)
+;DAC:              ; 36B: int NU_Create_Driver(NU_DRIVER *driver, CHAR *name, void (*driver_entry)(NU_DRIVER *, NU_DRIVER_REQUEST *))
+;DB0:              ; 36C: int NU_Delete_Driver(NU_DRIVER *driver)
+;DB4:              ; 36D: int NU_Request_Driver(NU_DRIVER *driver, NU_DRIVER_REQUEST *request)
+;DB8:              ; 36E: int NU_Resume_Driver(NU_TASK *task)
+;DBC:              ; 36F: int NU_Suspend_Driver(void (*terminate_routine)(void *), void *information, unsigned long timeout)
+
+;DC0:              ; 370: unsigned long NU_Established_Drivers(void)
+;DC4:              ; 371: unsigned long NU_Driver_Pointers(NU_DRIVER **pointer_list, unsigned long maximum_pointers)
+;DC8:              ; 372: unsigned long NU_IS_SUPERVISOR_MODE()
+;DCC:              ; 373: void NU_SUPERVISOR_MODE(unsigned long nu_svc_usr_var)
 0DD0: 0xA00A1284   ; 374: __arm NU_USER_MODE
 0DD4: 0xA8D96D24   ; 375: __arm NU_SUPERV_USER_VARIABLES
+;DD8:              ; 376:
+;DDC:              ; 377:
+;DE0:              ; 378:
+;DE4:              ; 379:
+;DE8:              ; 37A:
+;DEC:              ; 37B:
+;DF0:              ; 37C:
+;DF4:              ; 37D:
+;DF8:              ; 37E:
+;DFC:              ; 37F:
 
 0E00: 0xA096DF49   ; 380: WSHDR *GetClipBoard()
 0E04: 0xA096DEE1   ; 381: int CopyWsToClipboard(WSHDR *src)
@@ -883,15 +964,84 @@
 0E1C: 0xA0964E25   ; 387: LCDLAYER *GetLCDLAYERByCurCepID()
 0E20: 0xA0A04861   ; 388: void SetDepthBuffer(char depth)
 0E24: 0xA0A04815   ; 389: void SetDepthBufferOnLCDLAYER(LCDLAYER *, char depth)
-;E28:              ; 38A: void *RamAudioHookProc()
+;E28:              ; 38A: void *RamAudioHook()
 0E2C: 0xA8D95B90   ; 38B: char *RamLastStoreString()
-;0E30: 0x          ; 38C: int format(unsigned short drive, unsigned *error)
+;E30:              ; 38C: int sys_format(uint16_t drive, uint32_t *err)
 0E34: 0xA0251F0C   ; 38D: int stat(int fhandler, FStat *fstat, unsigned *error)
 0E38: 0xA0093124   ; 38E: void CreateICL(PGROUP *pg)
 0E3C: 0xA0098224   ; 38F: PGroupProc *CreatePGroupRes(int mask, int unk_zero, TaskConfig *conf, int size)
+
 0E40: 0xA0098E3C   ; 390: PGroupProc *PGroupCurrentTaskPointer()
 0E44: 0xA0093AB4   ; 391: void *MemMBPAlloc(void *pool, int size)
 0E48: 0xA00947A8   ; 392: void MemMBPFree(void *pool, void *ptr)
 0E4C: 0xA8DB49FC   ; 393: void *MopiResourcePool()
-#pragma disable old_equal_ff
-+0
+0E50: 0xA1086564   ; 394: RAND_METHOD *RAND_get_rand_method(void)
+0E54: 0xA0F859FB   ; 395: SSL_METHOD *TLSv1_client_method()
+0E58: 0xA0F87037   ; 396: SSL_CTX *SSL_CTX_new(SSL_METHOD *meth)
+0E5C: 0xA0F86433   ; 397: void SSL_CTX_free(SSL_CTX *ctx)
+0E60: 0xA0F8350B   ; 398: long SSL_CTX_ctrl(SSL_CTX *ctx, int cmd, long larg, void *parg)
+0E64: 0xA0F86603   ; 399: SSL *SSL_new(SSL_CTX *ctx)
+0E68: 0xA0F86823   ; 39A: int SSL_set_fd(SSL *s, int fd)
+0E6C: 0xA0F869C7   ; 39B: int SSL_connect(SSL *ssl)
+0E70: 0xA0F869E1   ; 39C: int SSL_shutdown(SSL *ssl)
+0E74: 0xA0F8235B   ; 39D: int SSL_read(SSL *ssl, void *buf, int num)
+0E78: 0xA0F823E1   ; 39E: int SSL_peek(SSL *ssl, void *buf, int num)
+0E7C: 0xA0F822BD   ; 39F: int SSL_write(SSL *ssl, const void *buf, int num)
+
+0E80: 0xA0F86709   ; 3A0: void SSL_free(SSL *ssl)
+0E84: 0xA0F87427   ; 3A1: int SSL_set_session(SSL *ssl, SSL_SESSION *session)
+0E88: 0xA0F812FF   ; 3A2: void SSL_SESSION_free(SSL_SESSION *sess)
+0E8C: 0xA0973013   ; 3A3: void SetMenuItemIconIMGHDR(void *gui, void *item, IMGHDR *icon)
+0E90: 0xA0A00515   ; 3A4: void LCDLAYER_Current_SetClipRegion(int x, int y, int x2, int y2)
+0E94: 0xA09FFBD3   ; 3A5: void DrawIMGHDR(int x, int y, IMGHDR *img)
+0E98: 0xA09133E5   ; 3A6: void DrwObj_GetWH(DRWOBJ *drwobj, int *w, int *h)
+0E9C: 0xA096B72F   ; 3A7: int GUI_NewTimer(void *gui)
+0EA0: 0xA096B873   ; 3A8: int GUI_DeleteTimer(void *gui, int id)
+0EA4: 0xA096B7C3   ; 3A9: void GUI_StartTimerProc(void *gui, int id, long timeout_ms, GUI_TimerProc callback)
+0EA8: 0xA0FF99A5   ; 3AA: void qsort(void *first, size_t nitems, size_t size, int (*comparator)(const void *, const void *))
+0EAC: 0xA0FF8C8D   ; 3AB: void *bsearch(const void *key, const void *first, size_t nitems, size_t size, int (*comparator)(const void *, const void *))
+;EB0:              ; 3AC: int EVP_add_cipher(EVP_CIPHER *c)
+;EB4:              ; 3AD:
+;EB8:              ; 3AE:
+;EBC:              ; 3AF:
+
+;EC0:              ; 3B0: void SettingsAE_RegisterListener(SettingsAE_ListenerProc proc, int set_id, const char *entry, const char *keyword)
+;EC4:              ; 3B1: void SettingsAE_DeregisterListener(SettingsAE_ListenerProc proc, int set_id, const char *entry, const char *keyword)
+;EC8:              ; 3B2: const WSHDR *GetLastAudioTrackDir()
+;ECC:              ; 3B3: IMGHDR *GetIMGHDRFromCanvasCache(char canvas_id)
+;ED0:              ; 3B4: void GetDate_ws(WSHDR *ws, const TDate *date, unsigned int unk)
+;ED4:              ; 3B5: void GetTime_ws(WSHDR *ws, const TTime *time, unsigned int unk)
+;ED8:              ; 3B6:
+;EDC:              ; 3B7: int sys_mkdir_ws(const WSHDR *dirname, uint32_t *err)
+;EE0:              ; 3B8:
+;EE4:              ; 3B9: int sys_rename_ws(const WSHDR *old_name, const WSHDR *new_name, uint32_t *err)
+;EE8:              ; 3BA:
+;EEC:              ; 3BB:
+;EF0:              ; 3BC: int isdir_ws(const WSHDR *path, uint32_t *err)
+;EF4:              ; 3BD:
+;EF8:              ; 3BE:
+;EFC:              ; 3BF:
+
+;F00:              ; 3C0: int ShowWaitBox(int flags, int message)
+;F04:              ; 3C1:
+;F08:              ; 3C2: int ShowPBarBox(int flags, int message, PBAR_DESC *pbar_desc, int initial_value, WSHDR *initial_ws)
+;F0C:              ; 3C3: int SetPBarValue(int gui_id, int value)
+;F10:              ; 3C4: int SetPBarText(int gui_id, WSHDR *ws)
+;F14:              ; 3C5: void *GetPBarProc3()
+;F18:              ; 3C6: void SetHeaderScrollText(void *header, const WSHDR *title, const void *malloc_fn, const void *mfree_fn)
+;F1C:              ; 3C7: void SetHeaderExtraText(void *header, const WSHDR *ws, const void *malloc_fn, const void *mfree_fn)
+;F20:              ; 3C8: int GetMimeType(int uid, WSHDR *mime_type, int unk_0)
+;F24:              ; 3C9: int wstrncmp(const WSHDR *ws1, const WSHDR *ws2, size_t n)
+;F28:              ; 3CA:
+;F2C:              ; 3CB:
+;F30:              ; 3CC: int PersMenuCSM_Open(const WSHDR *file_name, const WSHDR *dir, int flag, int open_mode)
+;F34:              ; 3CD:
+;F38:              ; 3CE:
+;F3C:              ; 3CF:
+
+;F40:              ; 3D0: int ShowScreenSaverCodeProtection()
+;F44:              ; 3D1: void MediaProc_LaunchLastPlayback()
+;F48:              ; 3D2: int GetScreenSaverType()
+
+#pragma enable old_equal_ff
++0
\ No newline at end of file
